# 练习题 2 

## 2.1 
> A. 0011 1001 1010 0111 1111 1000
> B. 0xC97B
> C. 1101 0101 1110 0100 1100 
> D. 0X26E7B5

## 2.2 
| n   | 2**n(十进制) | 2**n(十六进制) |
|-----|-----|-----|
|  9   | 512    | 0X200    |
|  19   |  524288   |    0X80000 |
|  14  |  16384   | 0x4000    |
|  16  |  65536   | 0x10000   |
|  17  |  131072  | 0x20000   |
|  5   |  32      | 0x20       | 
|  7   |  128    | 0x80       |

## 2.3
| 十进制   | 二进制     | 十六进制   |
|----------|------------|-----------|
| 0 | 0000 0000 | 0x00 |
| 167 | 1010 0111 | 0xA7 |
| 62 | 0011 1110 | 0x3e  |
| 188 | 1011 1100 | 0xBC  |
| 55 | 0011 0111 | 0x37 |
| 136 | 1000 1000  |  0x88 |  
| 243 | 1111 0011 | 0xF3 |
| 82 | 0101 0010 | 0x52 |
| 172 | 1010 1100 | 0xAC |
| 231 | 1110 0111 | 0XE7 |

## 2.4 
A. 0X5044
B. 0X4FFC
C. 0X507C
D. 0x00AE

## 2.5 

>A. 小端法: 21  大端法: 87
>B. 小端法: 21 43 大端法: 87 65
>C. 小端法: 21 43 65 大端法: 87 65 43

## 2.6 
>A. 整数:  0011 0101 1001 0001 0100 0001 
>浮点数:    0100 1010 0101 0110 0100 0101 0000 0100

>B.  有 21位相匹配
>C.  除了最高位 1，整数的所有位都嵌在浮点数中，浮点数有一些非零的高位不与整数中的高位相匹配
   00000000001101011001000101000001
     01001010010101100100010100000100

## 2.7 
> 61 62 63 64 65 66

## 2.8 


|  运算   | 结果    | 
|----------|------------|
| a | [01101001] | 
| b | [01010101] | 
| ~a | [10010110] | 
| ~b | [10101010] |
| a&b | [01000001] |
| a|b | [01111101]  |
| a^b | [00111100]| 

## 2.9 

>A.


|   颜色    | 补    |
|----------|-------|
| 黑色     | [111] |
| 红色     | [011] |
| 蓝色     | [110] |
| 红紫色     | [010] |
| 绿色     | [101] |
| 黄色     | [001] |
| 蓝绿色     | [100] |
| 白色     | [000] |

>B.

蓝色  | 绿色 =  蓝绿色
黄色  & 蓝绿色 = 绿色
红色  ^ 红紫色 = 蓝色

## 2.10

|    步骤   |    *x    |     *y     |
|-----------|---------|-------------|
|   初始    |    a     |     b       |
| 第一步    | a   |     a ^ b |
| 第二步    | b | a ^ b |
| 第三步    | b | a |


## 2.11 

>A. first = last = k 
>B. a ^ a = 0 
>C. first <= last 修改为 first < last 

## 2.12 

>A. x & 0xFF
>B. x ^ ~0xFF
>C. x | 0xFF

## 2.13
```c
// or 
int result = bis(x,y)
// xor
int result = bis(bic(x,y),bic(y,x))
```


## 2.14 
> 
> x & y  0x20  
x && y   0x01
x | y    0x7F
x || y   0x01 
~x | ~y  0xDF
!x || !y 0x00 
x & !y   0x00
x && ~y  0x01

## 2.15 
>A. !(x ^ y)


## 2.16 

<table>
  <tr>
    <th colspan="2">x</th>
    <th colspan="2">x<<3</th>
    <th colspan="2">x>>2(逻辑的)</th>
    <th colspan="2">x>>2(算术的)</th>
  </tr>
  <tr>
    <td>十六进制</td>
    <td>二进制</td>
    <td>二进制</td>
    <td>十六进制</td>
    <td>二进制</td>
    <td>十六进制</td>
    <td>二进制</td>
    <td>十六进制</td>
  </tr>
  <tr>
    <td>0xC3</td>
    <td>11000011</td>
    <td>00011000</td>
    <td>0x18</td>
    <td>00110000</td>
    <td>0x30</td>
    <td>11110000</td>
    <td>0xF0</td>
  </tr>
  <tr>
    <td>0x75</td>
    <td>01110101</td>
    <td>10101000</td>
    <td>0xA8</td>
    <td>00011101</td>
    <td>0x1D</td>
    <td>00011101</td>
    <td>0x1D</td>
  </tr>
  <tr>
    <td>0x87</td>
    <td>10000111</td>
    <td>00111000</td>
    <td>0x38</td>
    <td>00100001</td>
    <td>0x21</td>
    <td>11100001</td>
    <td>0xE1</td>
  </tr>
  <tr>
    <td>0x66</td>
    <td>01100110</td>
    <td>00110000</td>
    <td>0x30</td>
    <td>00011001</td>
    <td>0x19</td>
    <td>00011001</td>
    <td>0x19</td>
  </tr>
</table>


## 2.17
<table>
  <tr>
    <th colspan="2">x 位向量</th>
    <th rowspan="2">B2U4(x)</th>
    <th rowspan="2">B2T4(x)</th>
  </tr>
  <tr>
    <td>十六进制</td>
    <td>二进制</td>
  </tr>
  <tr>
    <td>0xE</td>
    <td>[1110]</td>
    <td>2**3+2**2+2**1=14</td>
    <td>-2**3	+ 2**2 + 2**1 = -2</td>
  </tr>
  <tr>
    <td>0x0</td>
    <td>[0000]</td>
    <td>0</td>
    <td>0</td>
  </tr>
  <tr>
    <td>0x5</td>
    <td>[0101]</td>
    <td>2**2	+ 2**0=5</td>
    <td>2**2+2**0=5</td>
  </tr>
  <tr>
    <td>0x8</td>
    <td>[1000]</td>
    <td>2**3=8</td>
    <td>-2**3=-8</td>
  </tr>
  <tr>
    <td>0xD</td>
    <td>[1101]</td>
    <td>2**3+2**2+2**0=13</td>
    <td>-2**3+2**2+2**0=-3</td>
  </tr>
  <tr>
    <td>0xF</td>
    <td>[1111]</td>
    <td>2**3+2**2+2**1+2**0=15</td>
    <td>-2**3+2**2+2**1+2**0=-1</td>
  </tr>
</table>


## 2.18 

>A. 736
>B. -88
>C. 40
>D. -48
>E. 120
>F. 136
>G. 504
>H. 192
>I. -72

## 练习 2.19

|     x   |   T2U4(x)   |
|---------|-------|
|-8|8|
|-3|13|
|-2|14|
|-1|15|
|0|0|
|5|5|

## 练习 2.20
> 对于 4 位有符号数，TMinw = -16, TMaxw = 15 

## 练习 2.21

|   表达式  |   类型   |   求值   |
|-----------|---------|--------|
|-214483647-1=2147483648U| 无符号 |  1 | 
|-2147483647-1<2147483647| 有符号 | 1 | 
|-2147483647-1U<2147483647|> 无符号 |  0 | 
|-2147483647-1<-2147483647|  有符号 | 1 |  
|-2147483647-1U<-2147483647| 无符号 | 1 |  


## 练习 2.22
> A. [1011]  -2**3 + 2**1 + 2**0 = -5
> B. [11011]  -2**4 + 2**3 + 2**1 + 2**0 = -5
> C. [111011]  -2**5 + 2**4 + 2**3 + 2**1 + 2**0 = -5

## 练习 2.23
> A. 
| w | fun1(w) | fun2(w) |
|---|---------|---------|
|0x00000076|00x00000076|0x00000076|
|0x87654321|0x00000021|0x00000021|
|0x000000C9|0x000000C9|0xFFFFFFC9|
|0xEDCBA987|0x00000087|0xFFFFFF87|

>B. func1: 从参数的低 8 位中提取一个值，得到范围 0～255 的一个整数
>   func2: 从参数的低 8 位中提取一个值，接着执行符号扩展，得到范围 -128～127 的一个整数

## 练习 2.24

<table>
  <tr>
    <th colspan="2">十六进制</th>
    <th colspan="2">无符号</th>
    <th colspan="2">补码</th>
  </tr>
  <tr>
    <td>原始值</td><td>截断值</td><td>原始值</td><td>截断值</td><td>原始值</td><td>截断值</td>
  </tr>
  <tr>
    <td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td>
  </tr>
  <tr>
    <td>2</td><td>2</td><td>2</td><td>2</td><td>2</td><td>2</td>
  </tr>
  <tr>
    <td>9</td><td>1</td><td>9</td><td>1</td><td>-7</td><td>1</td>
  </tr>
  <tr>
    <td>B</td><td>3</td><td>11</td><td>3</td><td>-5</td><td>3</td>
  </tr>
  <tr>
    <td>F</td><td>7</td><td>15</td><td>7</td><td>-1</td><td>-1</td>
  </tr>
</table>


## 练习 2.25
> 因为参数 length 是无符号的，计算 0-1 将使用无符号运算，这等价于模数加法。结果得到 UMax。<=比较同样使用无符号数比较，而因为任何数都是小于或者等于 UMax 的，所以这个比价总是为真！因此，代码将试图访问数组 a 的非法元素。
> 有两种方法可以改正这段代码，其一是将 length 声明为 int 类型，其二是将 for循环的测试条件改为 i<length 。
> *无符号数的减法会自动模*
>

## 练习 2.26
> A. 在 s 的长度小于 t 的长度 时，会产生不正确的结果
> B. 此时为 strlen(s)-strlen(t)为负，变成了一个很大的无符号数，恒大于0
> C. 将测试语句改成: return strlen(s)> strlen(t);或者修改为 return (int)(strlen(s))- (int)(strlen(t))

## 练习 2.27

```C
int uadd_ok(unsigned x, unsigned y){

  unsigned sum = x + y;
  return sum >= x;
}

```

## 练习 2.28 

<table>
  <tr>
    <th colspan="2">x</th>
    <th colspan="2">-u4x</th>
  </tr>
  <tr>
    <td>十六进制</td>
    <td>十进制</td>
    <td>十进制</td>
    <td>十六进制</td>
  </tr>
  <tr>
    <td>0</td>
    <td>0</td>
    <td>0</td>
    <td>0</td>
  </tr>
  <tr>
    <td>5</td>
    <td>5</td>
    <td>11</td>
    <td>B</td>
  </tr>
  <tr>
    <td>8</td>
    <td>8</td>
    <td>8</td>
    <td>8</td>
  </tr>
  <tr>
    <td>D</td>
    <td>13</td>
    <td>3</td>
    <td>3</td>
  </tr>  
  <tr>
    <td>F</td>
    <td>15</td>
    <td>1</td>
    <td>1</td>
  </tr>
</table>

## 练习 2.29

| x  | y  | x+y | x+t5y | 情况|
|----|----|------|-------|----|
|-12[10100]|-15[10001]|-27[100101]|5[00101]|1|
|-8[11000]|-8[11000]|-16[110000]|-16[10000]|2|
|-9[10111]|8[01000]|-1[11111]|-1[11111]|2|
|2[00010]|5[00101]|7[00111]|7[00111]|3|
|12[01100]|4[00100]|16[10000]|-16[10000]|4|

## 练习 2.30

```C
int tadd_ok(int x, int y){
  int sum = x + y;
  int neg_overflow = x < 0 && y < 0 && sum >= 0;
  int pos_overflow = x >= 0 && y >= 0 && sum < 0;
  return !neg_overflow && !pos_overflow;
}

// 另一种实现
// a ^ 0 = a
// a ^ a = 0
int tadd_ok(int x, int y){
  // 当 x 或 y 为 0 时，代码逻辑也成立
  if ((x ^ y) >=0) &&(x ^ sum) < 0)){
    return 0;
  }
  return 1;
}
```

## 练习 2.31
> 补码加会形成一个阿贝尔群，因此表达式(x+y)-x 求值得到 y,无论加法是否溢出，而(x+y)-y 总是会求值得到 x 

## 练习 2.32
> 这个函数会给出正确的值，除了当y等于TMin 时。
> 补码最小负数的绝对值比最大正数大1.
> 在这个情况下，我们有-y 也等于 TMin，因此函数 tadd_ok 会认为只要 x 是负数时，就会溢出，而x 为非负数时，不会溢出。实际上，情况恰恰相反：当 x 为负数时，tsub_ok(x,TMin)为 1；当 x 为非负数时，tsub_ok(x,TMin)为 0。

```C
//  正确实现
int tsub_ok(int x, int y){
  if (y==INT_MIN){
    return x == INT_MIN
  }
  return tadd_ok(x, -y);
}
```

> 题目用 tadd_ok(x, -y) 来判断 x - y 是否溢出。
但如果 y = INT_MIN，-y 这个操作本身就溢出了，结果还是 INT_MIN，不是你想要的 2147483648。
这时 tadd_ok(x, -y) 实际上判断的是 x + INT_MIN，而不是 x - y。
这样就会漏掉溢出的情况。


假设 x = 0, y = INT_MIN：

x - y = 0 - (-2147483648) = 2147483648，溢出（因为超出 int 范围）
但 -y = -(-2147483648) = -2147483648（溢出，还是 INT_MIN）
tadd_ok(0, -2147483648) 实际判断 0 + (-2147483648)，不会溢出，返回 1
但实际上 0 - (-2147483648) 溢出了，应该返回 0

结论: y = INT_MIN 时，-y 无法用 int 表示，结果溢出，导致 tadd_ok(x, -y) 判断失效。
这就是为什么 y = INT_MIN 会出错。


## 练习 2.33 

<table>
  <tr>
    <th colspan="2">x</th>
    <th colspan="2">-t4x</th>
  </tr>
  <tr>
    <td>十六进制</td>
    <td>十进制</td>
    <td>十进制</td>
    <td>十六进制</td>
  </tr>
  <tr>
    <td>0</td>
    <td>0</td>
    <td>0</td>
    <td>0</td>
  </tr>
  <tr>
    <td>5</td>
    <td>5</td>
    <td>-5</td>
    <td>B</td>
  </tr>
  <tr>
    <td>8</td>
    <td>-8</td>
    <td>-8</td>
    <td>8</td>
  </tr>
  <tr>
    <td>D</td>
    <td>-3</td>
    <td>3</td>
    <td>3</td>
  </tr>  
  <tr>
    <td>F</td>
    <td>-1</td>
    <td>1</td>
    <td>1</td>
  </tr>
</table>